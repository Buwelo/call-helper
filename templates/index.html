<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    <style type="text/tailwindcss">
        @theme {
          --color-clifford: #da373d;
        }
    </style>
    <title>Document</title>
</head>
<body class="p-4">
    <div class="space-y-4 grid gap-4 justify-items-center">
        <audio controls class="w-full" id="audioPlayer">
            <source src="{{ url_for('static', filename='call_with_mark.m4a') }}" type="audio/mpeg">
            Your browser does not support the audio element.
        </audio>
        <div class="w-full text-center text-sm text-gray-500" id="time-display">0:00:00</div>
        <input type="text" id="transcript" class="w-full p-2 border rounded" placeholder="Current subtitle" readonly>
        <textarea id="editable-transcript" class="w-full p-2 border rounded" rows="4" placeholder="Full transcript"></textarea>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const audioPlayer = document.getElementById('audioPlayer');
        const transcript = document.getElementById('transcript');
        const timeDisplay = document.getElementById('time-display');
        const editableTranscript = document.getElementById('editable-transcript');
        let eventSource = null;
        let lastTime = -1;

        const formatTime = (time) => {
            const hours = Math.floor(time / 3600);
            const minutes = Math.floor((time % 3600) / 60);
            const seconds = Math.floor(time % 60);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        };

        function connectEventSource(currentTime) {
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource(`/stream?currenttime=${currentTime}`);
            
            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    transcript.value = data.text;
                    
                    // Only append to editable transcript if it's new text
                    if (data.text && !editableTranscript.value.endsWith(data.text)) {
                        // Store current cursor and scroll position
                        const cursorPosition = editableTranscript.selectionStart;
                        const cursorEnd = editableTranscript.selectionEnd;
                        const scrollTop = editableTranscript.scrollTop;
                        
                        // Get current content
                        let newValue = editableTranscript.value;
                        
                        // Add newline if needed and append new text
                        if (newValue) {
                            newValue += '\n';
                        }
                        newValue += `[${formatTime(data.start)}] ${data.text}`;
                        
                        // Update the textarea
                        editableTranscript.value = newValue;
                        
                        // If user was actively editing (cursor position not at end),
                        // restore their position
                        if (cursorPosition !== editableTranscript.value.length - data.text.length - 1) {
                            editableTranscript.setSelectionRange(cursorPosition, cursorEnd);
                            editableTranscript.scrollTop = scrollTop;
                        } else {
                            // If cursor was at end, keep it at end
                            editableTranscript.setSelectionRange(newValue.length, newValue.length);
                            // Optional: scroll to bottom only if user was already at bottom
                            if (scrollTop + editableTranscript.clientHeight === editableTranscript.scrollHeight) {
                                editableTranscript.scrollTop = editableTranscript.scrollHeight;
                            }
                        }
                        
                        console.log('data text ', data.text);
                    }
                } catch (e) {
                    console.error('Error parsing subtitle data:', e);
                }
            };

            eventSource.onerror = function(error) {
                console.error('EventSource failed:', error);
                if (eventSource) {
                    eventSource.close();
                    eventSource = null;
                }
            };
        }

        // Update time display and check for subtitle updates
        audioPlayer.addEventListener('timeupdate', () => {
            const currentTime = audioPlayer.currentTime;
            timeDisplay.textContent = formatTime(currentTime);
            
            // Only update if time has changed significantly (100ms)
            if (Math.abs(currentTime - lastTime) >= 0.1) {
                lastTime = currentTime;
                if (!eventSource || eventSource.readyState !== EventSource.OPEN) {
                    connectEventSource(currentTime);
                } else {
                    // Reconnect with new time
                    connectEventSource(currentTime);
                }
            }
        });

        // Handle playback controls
        audioPlayer.addEventListener('play', () => {
            connectEventSource(audioPlayer.currentTime);
        });

        audioPlayer.addEventListener('pause', () => {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
        });

        audioPlayer.addEventListener('seeking', () => {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            transcript.value = '';  // Clear current subtitle while seeking
        });

        audioPlayer.addEventListener('seeked', () => {
            connectEventSource(audioPlayer.currentTime);
        });

        audioPlayer.addEventListener('ended', () => {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
        });
    });
    </script>
</body>
</html>